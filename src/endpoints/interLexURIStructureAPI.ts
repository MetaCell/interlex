/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * InterLex URI structure API
 * Resolution, update, and compare for ontologies and ontology identifiers.
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



export const getEndpointsOps = (
    group: string,
    operation: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/Operations/${group}/ops/${operation}`,options
    );
  }


export const getGetEndpointsOpsQueryKey = (group: string,
    operation: string,) => {
    return [`/api/v1/Operations/${group}/ops/${operation}`] as const;
    }

    
export const getGetEndpointsOpsQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsOps>>, TError = AxiosError<unknown>>(group: string,
    operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsOps>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsOpsQueryKey(group,operation);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsOps>>> = ({ signal }) => getEndpointsOps(group,operation, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && operation), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsOps>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsOpsQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsOps>>>
export type GetEndpointsOpsQueryError = AxiosError<unknown>

export const useGetEndpointsOps = <TData = Awaited<ReturnType<typeof getEndpointsOps>>, TError = AxiosError<unknown>>(
 group: string,
    operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsOps>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsOpsQueryOptions(group,operation,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postEndpointsOps = (
    group: string,
    operation: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/Operations/${group}/ops/${operation}`,undefined,options
    );
  }



export const getPostEndpointsOpsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsOps>>, TError,{group: string;operation: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEndpointsOps>>, TError,{group: string;operation: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEndpointsOps>>, {group: string;operation: string}> = (props) => {
          const {group,operation} = props ?? {};

          return  postEndpointsOps(group,operation,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEndpointsOpsMutationResult = NonNullable<Awaited<ReturnType<typeof postEndpointsOps>>>
    
    export type PostEndpointsOpsMutationError = AxiosError<unknown>

    export const usePostEndpointsOps = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsOps>>, TError,{group: string;operation: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEndpointsOps>>,
        TError,
        {group: string;operation: string},
        TContext
      > => {

      const mutationOptions = getPostEndpointsOpsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsPriv = (
    group: string,
    page: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/Privileged endpoints/${group}/priv/${page}`,options
    );
  }


export const getGetEndpointsPrivQueryKey = (group: string,
    page: string,) => {
    return [`/api/v1/Privileged endpoints/${group}/priv/${page}`] as const;
    }

    
export const getGetEndpointsPrivQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsPriv>>, TError = AxiosError<unknown>>(group: string,
    page: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsPriv>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsPrivQueryKey(group,page);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsPriv>>> = ({ signal }) => getEndpointsPriv(group,page, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && page), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsPriv>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsPrivQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsPriv>>>
export type GetEndpointsPrivQueryError = AxiosError<unknown>

export const useGetEndpointsPriv = <TData = Awaited<ReturnType<typeof getEndpointsPriv>>, TError = AxiosError<unknown>>(
 group: string,
    page: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsPriv>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsPrivQueryOptions(group,page,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postEndpointsPriv = (
    group: string,
    page: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/Privileged endpoints/${group}/priv/${page}`,undefined,options
    );
  }



export const getPostEndpointsPrivMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsPriv>>, TError,{group: string;page: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEndpointsPriv>>, TError,{group: string;page: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEndpointsPriv>>, {group: string;page: string}> = (props) => {
          const {group,page} = props ?? {};

          return  postEndpointsPriv(group,page,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEndpointsPrivMutationResult = NonNullable<Awaited<ReturnType<typeof postEndpointsPriv>>>
    
    export type PostEndpointsPrivMutationError = AxiosError<unknown>

    export const usePostEndpointsPriv = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsPriv>>, TError,{group: string;page: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEndpointsPriv>>,
        TError,
        {group: string;page: string},
        TContext
      > => {

      const mutationOptions = getPostEndpointsPrivMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsContributions = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/contributions/`,options
    );
  }


export const getGetEndpointsContributionsQueryKey = (group: string,) => {
    return [`/api/v1/${group}/contributions/`] as const;
    }

    
export const getGetEndpointsContributionsQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsContributions>>, TError = AxiosError<unknown>>(group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsContributionsQueryKey(group);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsContributions>>> = ({ signal }) => getEndpointsContributions(group, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsContributionsQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsContributions>>>
export type GetEndpointsContributionsQueryError = AxiosError<unknown>

export const useGetEndpointsContributions = <TData = Awaited<ReturnType<typeof getEndpointsContributions>>, TError = AxiosError<unknown>>(
 group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsContributionsQueryOptions(group,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getEndpointsContributions = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/contributions/interlex`,options
    );
  }


export const getGetEndpointsContributionsQueryKey = (group: string,) => {
    return [`/api/v1/${group}/contributions/interlex`] as const;
    }

    
export const getGetEndpointsContributionsQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsContributions>>, TError = AxiosError<unknown>>(group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsContributionsQueryKey(group);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsContributions>>> = ({ signal }) => getEndpointsContributions(group, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsContributionsQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsContributions>>>
export type GetEndpointsContributionsQueryError = AxiosError<unknown>

export const useGetEndpointsContributions = <TData = Awaited<ReturnType<typeof getEndpointsContributions>>, TError = AxiosError<unknown>>(
 group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsContributions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsContributionsQueryOptions(group,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getEndpointsCuries = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/curies/`,options
    );
  }


export const getGetEndpointsCuriesQueryKey = (group: string,) => {
    return [`/api/v1/${group}/curies/`] as const;
    }

    
export const getGetEndpointsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsCuries>>, TError = AxiosError<unknown>>(group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsCuriesQueryKey(group);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsCuries>>> = ({ signal }) => getEndpointsCuries(group, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsCuries>>>
export type GetEndpointsCuriesQueryError = AxiosError<unknown>

export const useGetEndpointsCuries = <TData = Awaited<ReturnType<typeof getEndpointsCuries>>, TError = AxiosError<unknown>>(
 group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsCuriesQueryOptions(group,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postEndpointsCuries = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/curies/`,undefined,options
    );
  }



export const getPostEndpointsCuriesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsCuries>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEndpointsCuries>>, TError,{group: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEndpointsCuries>>, {group: string}> = (props) => {
          const {group} = props ?? {};

          return  postEndpointsCuries(group,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEndpointsCuriesMutationResult = NonNullable<Awaited<ReturnType<typeof postEndpointsCuries>>>
    
    export type PostEndpointsCuriesMutationError = AxiosError<unknown>

    export const usePostEndpointsCuries = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsCuries>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEndpointsCuries>>,
        TError,
        {group: string},
        TContext
      > => {

      const mutationOptions = getPostEndpointsCuriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsCuries = (
    group: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetEndpointsCuriesQueryKey = (group: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetEndpointsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsCuries>>, TError = AxiosError<unknown>>(group: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsCuriesQueryKey(group,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsCuries>>> = ({ signal }) => getEndpointsCuries(group,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsCuries>>>
export type GetEndpointsCuriesQueryError = AxiosError<unknown>

export const useGetEndpointsCuries = <TData = Awaited<ReturnType<typeof getEndpointsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsCuriesQueryOptions(group,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffCuries = (
    group: string,
    otherGroupDiff: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/curies/`,options
    );
  }


export const getGetDiffCuriesQueryKey = (group: string,
    otherGroupDiff: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/curies/`] as const;
    }

    
export const getGetDiffCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getDiffCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffCuriesQueryKey(group,otherGroupDiff);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffCuries>>> = ({ signal }) => getDiffCuries(group,otherGroupDiff, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffCuries>>>
export type GetDiffCuriesQueryError = AxiosError<unknown>

export const useGetDiffCuries = <TData = Awaited<ReturnType<typeof getDiffCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffCuriesQueryOptions(group,otherGroupDiff,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffCuries = (
    group: string,
    otherGroupDiff: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetDiffCuriesQueryKey = (group: string,
    otherGroupDiff: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetDiffCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getDiffCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffCuriesQueryKey(group,otherGroupDiff,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffCuries>>> = ({ signal }) => getDiffCuries(group,otherGroupDiff,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffCuries>>>
export type GetDiffCuriesQueryError = AxiosError<unknown>

export const useGetDiffCuries = <TData = Awaited<ReturnType<typeof getDiffCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffCuriesQueryOptions(group,otherGroupDiff,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffLexical = (
    group: string,
    otherGroupDiff: string,
    label: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/lexical/${label}`,options
    );
  }


export const getGetDiffLexicalQueryKey = (group: string,
    otherGroupDiff: string,
    label: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/lexical/${label}`] as const;
    }

    
export const getGetDiffLexicalQueryOptions = <TData = Awaited<ReturnType<typeof getDiffLexical>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    label: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffLexical>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffLexicalQueryKey(group,otherGroupDiff,label);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffLexical>>> = ({ signal }) => getDiffLexical(group,otherGroupDiff,label, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && label), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffLexical>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffLexicalQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffLexical>>>
export type GetDiffLexicalQueryError = AxiosError<unknown>

export const useGetDiffLexical = <TData = Awaited<ReturnType<typeof getDiffLexical>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    label: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffLexical>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffLexicalQueryOptions(group,otherGroupDiff,label,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getDiffOntologiesContributions = (
    group: string,
    otherGroupDiff: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/contributions`,options
    );
  }


export const getGetDiffOntologiesContributionsQueryKey = (group: string,
    otherGroupDiff: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/contributions`] as const;
    }

    
export const getGetDiffOntologiesContributionsQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologiesContributions>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesContributionsQueryKey(group,otherGroupDiff);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologiesContributions>>> = ({ signal }) => getDiffOntologiesContributions(group,otherGroupDiff, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesContributions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesContributionsQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologiesContributions>>>
export type GetDiffOntologiesContributionsQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetDiffOntologiesContributions = <TData = Awaited<ReturnType<typeof getDiffOntologiesContributions>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesContributionsQueryOptions(group,otherGroupDiff,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getDiffOntologiesUris = (
    group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/uris/${ontPath}/${filename}/`,options
    );
  }


export const getGetDiffOntologiesUrisQueryKey = (group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/uris/${ontPath}/${filename}/`] as const;
    }

    
export const getGetDiffOntologiesUrisQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologiesUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesUrisQueryKey(group,otherGroupDiff,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologiesUris>>> = ({ signal }) => getDiffOntologiesUris(group,otherGroupDiff,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologiesUris>>>
export type GetDiffOntologiesUrisQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetDiffOntologiesUris = <TData = Awaited<ReturnType<typeof getDiffOntologiesUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesUrisQueryOptions(group,otherGroupDiff,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getDiffOntologiesUrisVersion = (
    group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetDiffOntologiesUrisVersionQueryKey = (group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetDiffOntologiesUrisVersionQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesUrisVersionQueryKey(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>> = ({ signal }) => getDiffOntologiesUrisVersion(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesUrisVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>>
export type GetDiffOntologiesUrisVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetDiffOntologiesUrisVersion = <TData = Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesUrisVersionQueryOptions(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary the main ontologies endpoint
 */
export const getDiffOntologies = (
    group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${ontPath}/${filename}/`,options
    );
  }


export const getGetDiffOntologiesQueryKey = (group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${ontPath}/${filename}/`] as const;
    }

    
export const getGetDiffOntologiesQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologies>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesQueryKey(group,otherGroupDiff,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologies>>> = ({ signal }) => getDiffOntologies(group,otherGroupDiff,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologies>>>
export type GetDiffOntologiesQueryError = AxiosError<unknown>

/**
 * @summary the main ontologies endpoint
 */
export const useGetDiffOntologies = <TData = Awaited<ReturnType<typeof getDiffOntologies>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesQueryOptions(group,otherGroupDiff,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getDiffOntologiesVersion = (
    group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetDiffOntologiesVersionQueryKey = (group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetDiffOntologiesVersionQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologiesVersion>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesVersionQueryKey(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologiesVersion>>> = ({ signal }) => getDiffOntologiesVersion(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologiesVersion>>>
export type GetDiffOntologiesVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetDiffOntologiesVersion = <TData = Awaited<ReturnType<typeof getDiffOntologiesVersion>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesVersionQueryOptions(group,otherGroupDiff,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffOntologiesIlx = (
    group: string,
    otherGroupDiff: string,
    fragPrefId: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${fragPrefId}.${extension}`,options
    );
  }


export const getGetDiffOntologiesIlxQueryKey = (group: string,
    otherGroupDiff: string,
    fragPrefId: string,
    extension: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/ontologies/${fragPrefId}.${extension}`] as const;
    }

    
export const getGetDiffOntologiesIlxQueryOptions = <TData = Awaited<ReturnType<typeof getDiffOntologiesIlx>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffOntologiesIlxQueryKey(group,otherGroupDiff,fragPrefId,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffOntologiesIlx>>> = ({ signal }) => getDiffOntologiesIlx(group,otherGroupDiff,fragPrefId,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && fragPrefId && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffOntologiesIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffOntologiesIlx>>>
export type GetDiffOntologiesIlxQueryError = AxiosError<unknown>

export const useGetDiffOntologiesIlx = <TData = Awaited<ReturnType<typeof getDiffOntologiesIlx>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffOntologiesIlxQueryOptions(group,otherGroupDiff,fragPrefId,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffReadable = (
    group: string,
    otherGroupDiff: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/readable/${word}`,options
    );
  }


export const getGetDiffReadableQueryKey = (group: string,
    otherGroupDiff: string,
    word: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/readable/${word}`] as const;
    }

    
export const getGetDiffReadableQueryOptions = <TData = Awaited<ReturnType<typeof getDiffReadable>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffReadable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffReadableQueryKey(group,otherGroupDiff,word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffReadable>>> = ({ signal }) => getDiffReadable(group,otherGroupDiff,word, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffReadable>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffReadableQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffReadable>>>
export type GetDiffReadableQueryError = AxiosError<unknown>

export const useGetDiffReadable = <TData = Awaited<ReturnType<typeof getDiffReadable>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffReadable>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffReadableQueryOptions(group,otherGroupDiff,word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffUris = (
    group: string,
    otherGroupDiff: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/uris/${uriPath}`,options
    );
  }


export const getGetDiffUrisQueryKey = (group: string,
    otherGroupDiff: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/uris/${uriPath}`] as const;
    }

    
export const getGetDiffUrisQueryOptions = <TData = Awaited<ReturnType<typeof getDiffUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffUrisQueryKey(group,otherGroupDiff,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffUris>>> = ({ signal }) => getDiffUris(group,otherGroupDiff,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffUris>>>
export type GetDiffUrisQueryError = AxiosError<unknown>

export const useGetDiffUris = <TData = Awaited<ReturnType<typeof getDiffUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffUrisQueryOptions(group,otherGroupDiff,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffVersionsCuries = (
    group: string,
    otherGroupDiff: string,
    epochVerstrId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/curies/`,options
    );
  }


export const getGetDiffVersionsCuriesQueryKey = (group: string,
    otherGroupDiff: string,
    epochVerstrId: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/curies/`] as const;
    }

    
export const getGetDiffVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffVersionsCuriesQueryKey(group,otherGroupDiff,epochVerstrId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffVersionsCuries>>> = ({ signal }) => getDiffVersionsCuries(group,otherGroupDiff,epochVerstrId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && epochVerstrId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffVersionsCuries>>>
export type GetDiffVersionsCuriesQueryError = AxiosError<unknown>

export const useGetDiffVersionsCuries = <TData = Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffVersionsCuriesQueryOptions(group,otherGroupDiff,epochVerstrId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffVersionsCuries = (
    group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetDiffVersionsCuriesQueryKey = (group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetDiffVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffVersionsCuriesQueryKey(group,otherGroupDiff,epochVerstrId,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffVersionsCuries>>> = ({ signal }) => getDiffVersionsCuries(group,otherGroupDiff,epochVerstrId,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && epochVerstrId && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffVersionsCuries>>>
export type GetDiffVersionsCuriesQueryError = AxiosError<unknown>

export const useGetDiffVersionsCuries = <TData = Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffVersionsCuriesQueryOptions(group,otherGroupDiff,epochVerstrId,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffVersionsReadable = (
    group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/readable/${word}`,options
    );
  }


export const getGetDiffVersionsReadableQueryKey = (group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    word: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/readable/${word}`] as const;
    }

    
export const getGetDiffVersionsReadableQueryOptions = <TData = Awaited<ReturnType<typeof getDiffVersionsReadable>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffVersionsReadableQueryKey(group,otherGroupDiff,epochVerstrId,word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffVersionsReadable>>> = ({ signal }) => getDiffVersionsReadable(group,otherGroupDiff,epochVerstrId,word, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && epochVerstrId && word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsReadable>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffVersionsReadableQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffVersionsReadable>>>
export type GetDiffVersionsReadableQueryError = AxiosError<unknown>

export const useGetDiffVersionsReadable = <TData = Awaited<ReturnType<typeof getDiffVersionsReadable>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffVersionsReadableQueryOptions(group,otherGroupDiff,epochVerstrId,word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffVersionsUris = (
    group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/uris/${uriPath}`,options
    );
  }


export const getGetDiffVersionsUrisQueryKey = (group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/uris/${uriPath}`] as const;
    }

    
export const getGetDiffVersionsUrisQueryOptions = <TData = Awaited<ReturnType<typeof getDiffVersionsUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffVersionsUrisQueryKey(group,otherGroupDiff,epochVerstrId,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffVersionsUris>>> = ({ signal }) => getDiffVersionsUris(group,otherGroupDiff,epochVerstrId,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && epochVerstrId && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffVersionsUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffVersionsUris>>>
export type GetDiffVersionsUrisQueryError = AxiosError<unknown>

export const useGetDiffVersionsUris = <TData = Awaited<ReturnType<typeof getDiffVersionsUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffVersionsUrisQueryOptions(group,otherGroupDiff,epochVerstrId,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffVersionsIlx = (
    group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/${fragPrefId}`,options
    );
  }


export const getGetDiffVersionsIlxQueryKey = (group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    fragPrefId: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/versions/${epochVerstrId}/${fragPrefId}`] as const;
    }

    
export const getGetDiffVersionsIlxQueryOptions = <TData = Awaited<ReturnType<typeof getDiffVersionsIlx>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffVersionsIlxQueryKey(group,otherGroupDiff,epochVerstrId,fragPrefId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffVersionsIlx>>> = ({ signal }) => getDiffVersionsIlx(group,otherGroupDiff,epochVerstrId,fragPrefId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && epochVerstrId && fragPrefId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffVersionsIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffVersionsIlx>>>
export type GetDiffVersionsIlxQueryError = AxiosError<unknown>

export const useGetDiffVersionsIlx = <TData = Awaited<ReturnType<typeof getDiffVersionsIlx>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffVersionsIlxQueryOptions(group,otherGroupDiff,epochVerstrId,fragPrefId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDiffIlx = (
    group: string,
    otherGroupDiff: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/diff/${otherGroupDiff}/${fragPrefId}`,options
    );
  }


export const getGetDiffIlxQueryKey = (group: string,
    otherGroupDiff: string,
    fragPrefId: string,) => {
    return [`/api/v1/${group}/diff/${otherGroupDiff}/${fragPrefId}`] as const;
    }

    
export const getGetDiffIlxQueryOptions = <TData = Awaited<ReturnType<typeof getDiffIlx>>, TError = AxiosError<unknown>>(group: string,
    otherGroupDiff: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDiffIlxQueryKey(group,otherGroupDiff,fragPrefId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDiffIlx>>> = ({ signal }) => getDiffIlx(group,otherGroupDiff,fragPrefId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroupDiff && fragPrefId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDiffIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDiffIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getDiffIlx>>>
export type GetDiffIlxQueryError = AxiosError<unknown>

export const useGetDiffIlx = <TData = Awaited<ReturnType<typeof getDiffIlx>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroupDiff: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDiffIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDiffIlxQueryOptions(group,otherGroupDiff,fragPrefId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getEndpointsMapped = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/external/mapped`,options
    );
  }


export const getGetEndpointsMappedQueryKey = (group: string,) => {
    return [`/api/v1/${group}/external/mapped`] as const;
    }

    
export const getGetEndpointsMappedQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsMapped>>, TError = AxiosError<unknown>>(group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsMapped>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsMappedQueryKey(group);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsMapped>>> = ({ signal }) => getEndpointsMapped(group, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsMapped>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsMappedQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsMapped>>>
export type GetEndpointsMappedQueryError = AxiosError<unknown>

export const useGetEndpointsMapped = <TData = Awaited<ReturnType<typeof getEndpointsMapped>>, TError = AxiosError<unknown>>(
 group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsMapped>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsMappedQueryOptions(group,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postEndpointsMapped = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/external/mapped`,undefined,options
    );
  }



export const getPostEndpointsMappedMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsMapped>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEndpointsMapped>>, TError,{group: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEndpointsMapped>>, {group: string}> = (props) => {
          const {group} = props ?? {};

          return  postEndpointsMapped(group,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEndpointsMappedMutationResult = NonNullable<Awaited<ReturnType<typeof postEndpointsMapped>>>
    
    export type PostEndpointsMappedMutationError = AxiosError<unknown>

    export const usePostEndpointsMapped = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsMapped>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEndpointsMapped>>,
        TError,
        {group: string},
        TContext
      > => {

      const mutationOptions = getPostEndpointsMappedMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsLexical = (
    group: string,
    label: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/lexical/${label}`,options
    );
  }


export const getGetEndpointsLexicalQueryKey = (group: string,
    label: string,) => {
    return [`/api/v1/${group}/lexical/${label}`] as const;
    }

    
export const getGetEndpointsLexicalQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsLexical>>, TError = AxiosError<unknown>>(group: string,
    label: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsLexical>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsLexicalQueryKey(group,label);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsLexical>>> = ({ signal }) => getEndpointsLexical(group,label, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && label), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsLexical>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsLexicalQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsLexical>>>
export type GetEndpointsLexicalQueryError = AxiosError<unknown>

export const useGetEndpointsLexical = <TData = Awaited<ReturnType<typeof getEndpointsLexical>>, TError = AxiosError<unknown>>(
 group: string,
    label: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsLexical>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsLexicalQueryOptions(group,label,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getOntologiesOntologiesContributions = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/contributions`,options
    );
  }


export const getGetOntologiesOntologiesContributionsQueryKey = (group: string,) => {
    return [`/api/v1/${group}/ontologies/contributions`] as const;
    }

    
export const getGetOntologiesOntologiesContributionsQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>, TError = AxiosError<unknown>>(group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesContributionsQueryKey(group);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>> = ({ signal }) => getOntologiesOntologiesContributions(group, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesContributionsQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>>
export type GetOntologiesOntologiesContributionsQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOntologiesOntologiesContributions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>, TError = AxiosError<unknown>>(
 group: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesContributionsQueryOptions(group,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getOntologiesOntologiesUris = (
    group: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/uris/${ontPath}/${filename}/`,options
    );
  }


export const getGetOntologiesOntologiesUrisQueryKey = (group: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/ontologies/uris/${ontPath}/${filename}/`] as const;
    }

    
export const getGetOntologiesOntologiesUrisQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesUris>>, TError = AxiosError<unknown>>(group: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesUrisQueryKey(group,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologiesUris>>> = ({ signal }) => getOntologiesOntologiesUris(group,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologiesUris>>>
export type GetOntologiesOntologiesUrisQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOntologiesOntologiesUris = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesUris>>, TError = AxiosError<unknown>>(
 group: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesUrisQueryOptions(group,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const postOntologiesOntologiesUris = (
    group: string,
    ontPath: string,
    filename: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/ontologies/uris/${ontPath}/${filename}.${extension}`,undefined,options
    );
  }



export const getPostOntologiesOntologiesUrisMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUris>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUris>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOntologiesOntologiesUris>>, {group: string;ontPath: string;filename: string;extension: string}> = (props) => {
          const {group,ontPath,filename,extension} = props ?? {};

          return  postOntologiesOntologiesUris(group,ontPath,filename,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOntologiesOntologiesUrisMutationResult = NonNullable<Awaited<ReturnType<typeof postOntologiesOntologiesUris>>>
    
    export type PostOntologiesOntologiesUrisMutationError = AxiosError<unknown>

    /**
 * @summary needed because ontologies appear under other routes
 */
export const usePostOntologiesOntologiesUris = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUris>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOntologiesOntologiesUris>>,
        TError,
        {group: string;ontPath: string;filename: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOntologiesOntologiesUrisMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary needed because ontologies appear under other routes
 */
export const getOntologiesOntologiesUrisVersion = (
    group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetOntologiesOntologiesUrisVersionQueryKey = (group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetOntologiesOntologiesUrisVersionQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>, TError = AxiosError<unknown>>(group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesUrisVersionQueryKey(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>> = ({ signal }) => getOntologiesOntologiesUrisVersion(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesUrisVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>>
export type GetOntologiesOntologiesUrisVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOntologiesOntologiesUrisVersion = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>, TError = AxiosError<unknown>>(
 group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesUrisVersionQueryOptions(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const postOntologiesOntologiesUrisVersion = (
    group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,undefined,options
    );
  }



export const getPostOntologiesOntologiesUrisVersionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>, TError,{group: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>, TError,{group: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>, {group: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}> = (props) => {
          const {group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension} = props ?? {};

          return  postOntologiesOntologiesUrisVersion(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOntologiesOntologiesUrisVersionMutationResult = NonNullable<Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>>
    
    export type PostOntologiesOntologiesUrisVersionMutationError = AxiosError<unknown>

    /**
 * @summary needed because ontologies appear under other routes
 */
export const usePostOntologiesOntologiesUrisVersion = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>, TError,{group: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOntologiesOntologiesUrisVersion>>,
        TError,
        {group: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOntologiesOntologiesUrisVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary the main ontologies endpoint
 */
export const getOntologiesOntologies = (
    group: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/${ontPath}/${filename}/`,options
    );
  }


export const getGetOntologiesOntologiesQueryKey = (group: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/ontologies/${ontPath}/${filename}/`] as const;
    }

    
export const getGetOntologiesOntologiesQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologies>>, TError = AxiosError<unknown>>(group: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesQueryKey(group,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologies>>> = ({ signal }) => getOntologiesOntologies(group,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologies>>>
export type GetOntologiesOntologiesQueryError = AxiosError<unknown>

/**
 * @summary the main ontologies endpoint
 */
export const useGetOntologiesOntologies = <TData = Awaited<ReturnType<typeof getOntologiesOntologies>>, TError = AxiosError<unknown>>(
 group: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesQueryOptions(group,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary the main ontologies endpoint
 */
export const postOntologiesOntologies = (
    group: string,
    ontPath: string,
    filename: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/ontologies/${ontPath}/${filename}.${extension}`,undefined,options
    );
  }



export const getPostOntologiesOntologiesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologies>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologies>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOntologiesOntologies>>, {group: string;ontPath: string;filename: string;extension: string}> = (props) => {
          const {group,ontPath,filename,extension} = props ?? {};

          return  postOntologiesOntologies(group,ontPath,filename,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOntologiesOntologiesMutationResult = NonNullable<Awaited<ReturnType<typeof postOntologiesOntologies>>>
    
    export type PostOntologiesOntologiesMutationError = AxiosError<unknown>

    /**
 * @summary the main ontologies endpoint
 */
export const usePostOntologiesOntologies = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOntologiesOntologies>>, TError,{group: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOntologiesOntologies>>,
        TError,
        {group: string;ontPath: string;filename: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOntologiesOntologiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary needed because ontologies appear under other routes
 */
export const getOntologiesOntologiesVersion = (
    group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetOntologiesOntologiesVersionQueryKey = (group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetOntologiesOntologiesVersionQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>, TError = AxiosError<unknown>>(group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesVersionQueryKey(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>> = ({ signal }) => getOntologiesOntologiesVersion(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>>
export type GetOntologiesOntologiesVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOntologiesOntologiesVersion = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>, TError = AxiosError<unknown>>(
 group: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesVersionQueryOptions(group,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOntologiesOntologiesIlx = (
    group: string,
    fragPrefId: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/ontologies/${fragPrefId}.${extension}`,options
    );
  }


export const getGetOntologiesOntologiesIlxQueryKey = (group: string,
    fragPrefId: string,
    extension: string,) => {
    return [`/api/v1/${group}/ontologies/${fragPrefId}.${extension}`] as const;
    }

    
export const getGetOntologiesOntologiesIlxQueryOptions = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>, TError = AxiosError<unknown>>(group: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOntologiesOntologiesIlxQueryKey(group,fragPrefId,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>> = ({ signal }) => getOntologiesOntologiesIlx(group,fragPrefId,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && fragPrefId && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOntologiesOntologiesIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>>
export type GetOntologiesOntologiesIlxQueryError = AxiosError<unknown>

export const useGetOntologiesOntologiesIlx = <TData = Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>, TError = AxiosError<unknown>>(
 group: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOntologiesOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOntologiesOntologiesIlxQueryOptions(group,fragPrefId,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnCuries = (
    group: string,
    otherGroup: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/curies/`,options
    );
  }


export const getGetOwnCuriesQueryKey = (group: string,
    otherGroup: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/curies/`] as const;
    }

    
export const getGetOwnCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getOwnCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnCuriesQueryKey(group,otherGroup);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnCuries>>> = ({ signal }) => getOwnCuries(group,otherGroup, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnCuries>>>
export type GetOwnCuriesQueryError = AxiosError<unknown>

export const useGetOwnCuries = <TData = Awaited<ReturnType<typeof getOwnCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnCuriesQueryOptions(group,otherGroup,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postOwnCuries = (
    group: string,
    otherGroup: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/own/${otherGroup}/curies/`,undefined,options
    );
  }



export const getPostOwnCuriesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnCuries>>, TError,{group: string;otherGroup: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOwnCuries>>, TError,{group: string;otherGroup: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOwnCuries>>, {group: string;otherGroup: string}> = (props) => {
          const {group,otherGroup} = props ?? {};

          return  postOwnCuries(group,otherGroup,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOwnCuriesMutationResult = NonNullable<Awaited<ReturnType<typeof postOwnCuries>>>
    
    export type PostOwnCuriesMutationError = AxiosError<unknown>

    export const usePostOwnCuries = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnCuries>>, TError,{group: string;otherGroup: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOwnCuries>>,
        TError,
        {group: string;otherGroup: string},
        TContext
      > => {

      const mutationOptions = getPostOwnCuriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getOwnCuries = (
    group: string,
    otherGroup: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetOwnCuriesQueryKey = (group: string,
    otherGroup: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetOwnCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getOwnCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnCuriesQueryKey(group,otherGroup,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnCuries>>> = ({ signal }) => getOwnCuries(group,otherGroup,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnCuries>>>
export type GetOwnCuriesQueryError = AxiosError<unknown>

export const useGetOwnCuries = <TData = Awaited<ReturnType<typeof getOwnCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnCuriesQueryOptions(group,otherGroup,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getOwnOntologiesContributions = (
    group: string,
    otherGroup: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/contributions`,options
    );
  }


export const getGetOwnOntologiesContributionsQueryKey = (group: string,
    otherGroup: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/contributions`] as const;
    }

    
export const getGetOwnOntologiesContributionsQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologiesContributions>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesContributionsQueryKey(group,otherGroup);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologiesContributions>>> = ({ signal }) => getOwnOntologiesContributions(group,otherGroup, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesContributions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesContributionsQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologiesContributions>>>
export type GetOwnOntologiesContributionsQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOwnOntologiesContributions = <TData = Awaited<ReturnType<typeof getOwnOntologiesContributions>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesContributions>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesContributionsQueryOptions(group,otherGroup,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const getOwnOntologiesUris = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}/`,options
    );
  }


export const getGetOwnOntologiesUrisQueryKey = (group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}/`] as const;
    }

    
export const getGetOwnOntologiesUrisQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologiesUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesUrisQueryKey(group,otherGroup,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologiesUris>>> = ({ signal }) => getOwnOntologiesUris(group,otherGroup,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologiesUris>>>
export type GetOwnOntologiesUrisQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOwnOntologiesUris = <TData = Awaited<ReturnType<typeof getOwnOntologiesUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesUrisQueryOptions(group,otherGroup,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const postOwnOntologiesUris = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}.${extension}`,undefined,options
    );
  }



export const getPostOwnOntologiesUrisMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUris>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUris>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOwnOntologiesUris>>, {group: string;otherGroup: string;ontPath: string;filename: string;extension: string}> = (props) => {
          const {group,otherGroup,ontPath,filename,extension} = props ?? {};

          return  postOwnOntologiesUris(group,otherGroup,ontPath,filename,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOwnOntologiesUrisMutationResult = NonNullable<Awaited<ReturnType<typeof postOwnOntologiesUris>>>
    
    export type PostOwnOntologiesUrisMutationError = AxiosError<unknown>

    /**
 * @summary needed because ontologies appear under other routes
 */
export const usePostOwnOntologiesUris = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUris>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOwnOntologiesUris>>,
        TError,
        {group: string;otherGroup: string;ontPath: string;filename: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOwnOntologiesUrisMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary needed because ontologies appear under other routes
 */
export const getOwnOntologiesUrisVersion = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetOwnOntologiesUrisVersionQueryKey = (group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetOwnOntologiesUrisVersionQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesUrisVersionQueryKey(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>> = ({ signal }) => getOwnOntologiesUrisVersion(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesUrisVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>>
export type GetOwnOntologiesUrisVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOwnOntologiesUrisVersion = <TData = Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesUrisVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesUrisVersionQueryOptions(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary needed because ontologies appear under other routes
 */
export const postOwnOntologiesUrisVersion = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/own/${otherGroup}/ontologies/uris/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,undefined,options
    );
  }



export const getPostOwnOntologiesUrisVersionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>, {group: string;otherGroup: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}> = (props) => {
          const {group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension} = props ?? {};

          return  postOwnOntologiesUrisVersion(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOwnOntologiesUrisVersionMutationResult = NonNullable<Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>>
    
    export type PostOwnOntologiesUrisVersionMutationError = AxiosError<unknown>

    /**
 * @summary needed because ontologies appear under other routes
 */
export const usePostOwnOntologiesUrisVersion = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOwnOntologiesUrisVersion>>,
        TError,
        {group: string;otherGroup: string;ontPath: string;filename: string;epochVerstrOnt: string;filenameTerminal: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOwnOntologiesUrisVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary the main ontologies endpoint
 */
export const getOwnOntologies = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/${ontPath}/${filename}/`,options
    );
  }


export const getGetOwnOntologiesQueryKey = (group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/${ontPath}/${filename}/`] as const;
    }

    
export const getGetOwnOntologiesQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologies>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesQueryKey(group,otherGroup,ontPath,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologies>>> = ({ signal }) => getOwnOntologies(group,otherGroup,ontPath,filename, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && ontPath && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologies>>>
export type GetOwnOntologiesQueryError = AxiosError<unknown>

/**
 * @summary the main ontologies endpoint
 */
export const useGetOwnOntologies = <TData = Awaited<ReturnType<typeof getOwnOntologies>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    ontPath: string,
    filename: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologies>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesQueryOptions(group,otherGroup,ontPath,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary the main ontologies endpoint
 */
export const postOwnOntologies = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/own/${otherGroup}/ontologies/${ontPath}/${filename}.${extension}`,undefined,options
    );
  }



export const getPostOwnOntologiesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologies>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologies>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOwnOntologies>>, {group: string;otherGroup: string;ontPath: string;filename: string;extension: string}> = (props) => {
          const {group,otherGroup,ontPath,filename,extension} = props ?? {};

          return  postOwnOntologies(group,otherGroup,ontPath,filename,extension,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOwnOntologiesMutationResult = NonNullable<Awaited<ReturnType<typeof postOwnOntologies>>>
    
    export type PostOwnOntologiesMutationError = AxiosError<unknown>

    /**
 * @summary the main ontologies endpoint
 */
export const usePostOwnOntologies = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOwnOntologies>>, TError,{group: string;otherGroup: string;ontPath: string;filename: string;extension: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOwnOntologies>>,
        TError,
        {group: string;otherGroup: string;ontPath: string;filename: string;extension: string},
        TContext
      > => {

      const mutationOptions = getPostOwnOntologiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary needed because ontologies appear under other routes
 */
export const getOwnOntologiesVersion = (
    group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`,options
    );
  }


export const getGetOwnOntologiesVersionQueryKey = (group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/${ontPath}/${filename}/version/${epochVerstrOnt}/${filenameTerminal}.${extension}`] as const;
    }

    
export const getGetOwnOntologiesVersionQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologiesVersion>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesVersionQueryKey(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologiesVersion>>> = ({ signal }) => getOwnOntologiesVersion(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && ontPath && filename && epochVerstrOnt && filenameTerminal && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologiesVersion>>>
export type GetOwnOntologiesVersionQueryError = AxiosError<unknown>

/**
 * @summary needed because ontologies appear under other routes
 */
export const useGetOwnOntologiesVersion = <TData = Awaited<ReturnType<typeof getOwnOntologiesVersion>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    ontPath: string,
    filename: string,
    epochVerstrOnt: string,
    filenameTerminal: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesVersion>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesVersionQueryOptions(group,otherGroup,ontPath,filename,epochVerstrOnt,filenameTerminal,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnOntologiesIlx = (
    group: string,
    otherGroup: string,
    fragPrefId: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/ontologies/${fragPrefId}.${extension}`,options
    );
  }


export const getGetOwnOntologiesIlxQueryKey = (group: string,
    otherGroup: string,
    fragPrefId: string,
    extension: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/ontologies/${fragPrefId}.${extension}`] as const;
    }

    
export const getGetOwnOntologiesIlxQueryOptions = <TData = Awaited<ReturnType<typeof getOwnOntologiesIlx>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnOntologiesIlxQueryKey(group,otherGroup,fragPrefId,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnOntologiesIlx>>> = ({ signal }) => getOwnOntologiesIlx(group,otherGroup,fragPrefId,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && fragPrefId && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnOntologiesIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnOntologiesIlx>>>
export type GetOwnOntologiesIlxQueryError = AxiosError<unknown>

export const useGetOwnOntologiesIlx = <TData = Awaited<ReturnType<typeof getOwnOntologiesIlx>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnOntologiesIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnOntologiesIlxQueryOptions(group,otherGroup,fragPrefId,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnUris = (
    group: string,
    otherGroup: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/uris/${uriPath}`,options
    );
  }


export const getGetOwnUrisQueryKey = (group: string,
    otherGroup: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/uris/${uriPath}`] as const;
    }

    
export const getGetOwnUrisQueryOptions = <TData = Awaited<ReturnType<typeof getOwnUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnUrisQueryKey(group,otherGroup,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnUris>>> = ({ signal }) => getOwnUris(group,otherGroup,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnUris>>>
export type GetOwnUrisQueryError = AxiosError<unknown>

export const useGetOwnUris = <TData = Awaited<ReturnType<typeof getOwnUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnUrisQueryOptions(group,otherGroup,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnVersionsCuries = (
    group: string,
    otherGroup: string,
    epochVerstrId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/curies/`,options
    );
  }


export const getGetOwnVersionsCuriesQueryKey = (group: string,
    otherGroup: string,
    epochVerstrId: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/curies/`] as const;
    }

    
export const getGetOwnVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnVersionsCuriesQueryKey(group,otherGroup,epochVerstrId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnVersionsCuries>>> = ({ signal }) => getOwnVersionsCuries(group,otherGroup,epochVerstrId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && epochVerstrId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnVersionsCuries>>>
export type GetOwnVersionsCuriesQueryError = AxiosError<unknown>

export const useGetOwnVersionsCuries = <TData = Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnVersionsCuriesQueryOptions(group,otherGroup,epochVerstrId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnVersionsCuries = (
    group: string,
    otherGroup: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetOwnVersionsCuriesQueryKey = (group: string,
    otherGroup: string,
    epochVerstrId: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetOwnVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnVersionsCuriesQueryKey(group,otherGroup,epochVerstrId,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnVersionsCuries>>> = ({ signal }) => getOwnVersionsCuries(group,otherGroup,epochVerstrId,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && epochVerstrId && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnVersionsCuries>>>
export type GetOwnVersionsCuriesQueryError = AxiosError<unknown>

export const useGetOwnVersionsCuries = <TData = Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnVersionsCuriesQueryOptions(group,otherGroup,epochVerstrId,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnVersionsReadable = (
    group: string,
    otherGroup: string,
    epochVerstrId: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/readable/${word}`,options
    );
  }


export const getGetOwnVersionsReadableQueryKey = (group: string,
    otherGroup: string,
    epochVerstrId: string,
    word: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/readable/${word}`] as const;
    }

    
export const getGetOwnVersionsReadableQueryOptions = <TData = Awaited<ReturnType<typeof getOwnVersionsReadable>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnVersionsReadableQueryKey(group,otherGroup,epochVerstrId,word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnVersionsReadable>>> = ({ signal }) => getOwnVersionsReadable(group,otherGroup,epochVerstrId,word, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && epochVerstrId && word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsReadable>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnVersionsReadableQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnVersionsReadable>>>
export type GetOwnVersionsReadableQueryError = AxiosError<unknown>

export const useGetOwnVersionsReadable = <TData = Awaited<ReturnType<typeof getOwnVersionsReadable>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnVersionsReadableQueryOptions(group,otherGroup,epochVerstrId,word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnVersionsUris = (
    group: string,
    otherGroup: string,
    epochVerstrId: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/uris/${uriPath}`,options
    );
  }


export const getGetOwnVersionsUrisQueryKey = (group: string,
    otherGroup: string,
    epochVerstrId: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/uris/${uriPath}`] as const;
    }

    
export const getGetOwnVersionsUrisQueryOptions = <TData = Awaited<ReturnType<typeof getOwnVersionsUris>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnVersionsUrisQueryKey(group,otherGroup,epochVerstrId,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnVersionsUris>>> = ({ signal }) => getOwnVersionsUris(group,otherGroup,epochVerstrId,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && epochVerstrId && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnVersionsUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnVersionsUris>>>
export type GetOwnVersionsUrisQueryError = AxiosError<unknown>

export const useGetOwnVersionsUris = <TData = Awaited<ReturnType<typeof getOwnVersionsUris>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnVersionsUrisQueryOptions(group,otherGroup,epochVerstrId,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getOwnVersionsIlx = (
    group: string,
    otherGroup: string,
    epochVerstrId: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/${fragPrefId}`,options
    );
  }


export const getGetOwnVersionsIlxQueryKey = (group: string,
    otherGroup: string,
    epochVerstrId: string,
    fragPrefId: string,) => {
    return [`/api/v1/${group}/own/${otherGroup}/versions/${epochVerstrId}/${fragPrefId}`] as const;
    }

    
export const getGetOwnVersionsIlxQueryOptions = <TData = Awaited<ReturnType<typeof getOwnVersionsIlx>>, TError = AxiosError<unknown>>(group: string,
    otherGroup: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOwnVersionsIlxQueryKey(group,otherGroup,epochVerstrId,fragPrefId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOwnVersionsIlx>>> = ({ signal }) => getOwnVersionsIlx(group,otherGroup,epochVerstrId,fragPrefId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && otherGroup && epochVerstrId && fragPrefId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOwnVersionsIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getOwnVersionsIlx>>>
export type GetOwnVersionsIlxQueryError = AxiosError<unknown>

export const useGetOwnVersionsIlx = <TData = Awaited<ReturnType<typeof getOwnVersionsIlx>>, TError = AxiosError<unknown>>(
 group: string,
    otherGroup: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOwnVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetOwnVersionsIlxQueryOptions(group,otherGroup,epochVerstrId,fragPrefId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Show users their personal uploads and then their groups.
Show groups all uploads with the user who did it
 * @summary Return all the identities that an org/user has uploaded
 */
export const getEndpointsProv = (
    group: string,
    identity: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/prov/identities/${identity}`,options
    );
  }


export const getGetEndpointsProvQueryKey = (group: string,
    identity: string,) => {
    return [`/api/v1/${group}/prov/identities/${identity}`] as const;
    }

    
export const getGetEndpointsProvQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsProv>>, TError = AxiosError<unknown>>(group: string,
    identity: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsProv>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsProvQueryKey(group,identity);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsProv>>> = ({ signal }) => getEndpointsProv(group,identity, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && identity), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsProv>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsProvQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsProv>>>
export type GetEndpointsProvQueryError = AxiosError<unknown>

/**
 * @summary Return all the identities that an org/user has uploaded
 */
export const useGetEndpointsProv = <TData = Awaited<ReturnType<typeof getEndpointsProv>>, TError = AxiosError<unknown>>(
 group: string,
    identity: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsProv>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsProvQueryOptions(group,identity,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getEndpointsReadable = (
    group: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/readable/${word}`,options
    );
  }


export const getGetEndpointsReadableQueryKey = (group: string,
    word: string,) => {
    return [`/api/v1/${group}/readable/${word}`] as const;
    }

    
export const getGetEndpointsReadableQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsReadable>>, TError = AxiosError<unknown>>(group: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsReadableQueryKey(group,word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsReadable>>> = ({ signal }) => getEndpointsReadable(group,word, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsReadable>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsReadableQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsReadable>>>
export type GetEndpointsReadableQueryError = AxiosError<unknown>

export const useGetEndpointsReadable = <TData = Awaited<ReturnType<typeof getEndpointsReadable>>, TError = AxiosError<unknown>>(
 group: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsReadableQueryOptions(group,word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const patchEndpointsReadable = (
    group: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.patch(
      `/api/v1/${group}/readable/${word}`,undefined,options
    );
  }



export const getPatchEndpointsReadableMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsReadable>>, TError,{group: string;word: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsReadable>>, TError,{group: string;word: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchEndpointsReadable>>, {group: string;word: string}> = (props) => {
          const {group,word} = props ?? {};

          return  patchEndpointsReadable(group,word,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchEndpointsReadableMutationResult = NonNullable<Awaited<ReturnType<typeof patchEndpointsReadable>>>
    
    export type PatchEndpointsReadableMutationError = AxiosError<unknown>

    export const usePatchEndpointsReadable = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsReadable>>, TError,{group: string;word: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchEndpointsReadable>>,
        TError,
        {group: string;word: string},
        TContext
      > => {

      const mutationOptions = getPatchEndpointsReadableMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Expects files
 */
export const postEndpointsUpload = (
    group: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `/api/v1/${group}/upload`,undefined,options
    );
  }



export const getPostEndpointsUploadMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsUpload>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postEndpointsUpload>>, TError,{group: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEndpointsUpload>>, {group: string}> = (props) => {
          const {group} = props ?? {};

          return  postEndpointsUpload(group,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEndpointsUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postEndpointsUpload>>>
    
    export type PostEndpointsUploadMutationError = AxiosError<unknown>

    /**
 * @summary Expects files
 */
export const usePostEndpointsUpload = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEndpointsUpload>>, TError,{group: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postEndpointsUpload>>,
        TError,
        {group: string},
        TContext
      > => {

      const mutationOptions = getPostEndpointsUploadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsUris = (
    group: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/uris/${uriPath}`,options
    );
  }


export const getGetEndpointsUrisQueryKey = (group: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/uris/${uriPath}`] as const;
    }

    
export const getGetEndpointsUrisQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsUris>>, TError = AxiosError<unknown>>(group: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsUrisQueryKey(group,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsUris>>> = ({ signal }) => getEndpointsUris(group,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsUris>>>
export type GetEndpointsUrisQueryError = AxiosError<unknown>

export const useGetEndpointsUris = <TData = Awaited<ReturnType<typeof getEndpointsUris>>, TError = AxiosError<unknown>>(
 group: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsUrisQueryOptions(group,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionsCuries = (
    group: string,
    epochVerstrId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/versions/${epochVerstrId}/curies/`,options
    );
  }


export const getGetVersionsCuriesQueryKey = (group: string,
    epochVerstrId: string,) => {
    return [`/api/v1/${group}/versions/${epochVerstrId}/curies/`] as const;
    }

    
export const getGetVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsCuriesQueryKey(group,epochVerstrId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsCuries>>> = ({ signal }) => getVersionsCuries(group,epochVerstrId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && epochVerstrId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionsCuries>>>
export type GetVersionsCuriesQueryError = AxiosError<unknown>

export const useGetVersionsCuries = <TData = Awaited<ReturnType<typeof getVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    epochVerstrId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetVersionsCuriesQueryOptions(group,epochVerstrId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionsCuries = (
    group: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/versions/${epochVerstrId}/curies/${prefixIriCurie}`,options
    );
  }


export const getGetVersionsCuriesQueryKey = (group: string,
    epochVerstrId: string,
    prefixIriCurie: string,) => {
    return [`/api/v1/${group}/versions/${epochVerstrId}/curies/${prefixIriCurie}`] as const;
    }

    
export const getGetVersionsCuriesQueryOptions = <TData = Awaited<ReturnType<typeof getVersionsCuries>>, TError = AxiosError<unknown>>(group: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsCuriesQueryKey(group,epochVerstrId,prefixIriCurie);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsCuries>>> = ({ signal }) => getVersionsCuries(group,epochVerstrId,prefixIriCurie, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && epochVerstrId && prefixIriCurie), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData> & { queryKey: QueryKey }
}

export type GetVersionsCuriesQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionsCuries>>>
export type GetVersionsCuriesQueryError = AxiosError<unknown>

export const useGetVersionsCuries = <TData = Awaited<ReturnType<typeof getVersionsCuries>>, TError = AxiosError<unknown>>(
 group: string,
    epochVerstrId: string,
    prefixIriCurie: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsCuries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetVersionsCuriesQueryOptions(group,epochVerstrId,prefixIriCurie,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionsReadable = (
    group: string,
    epochVerstrId: string,
    word: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/versions/${epochVerstrId}/readable/${word}`,options
    );
  }


export const getGetVersionsReadableQueryKey = (group: string,
    epochVerstrId: string,
    word: string,) => {
    return [`/api/v1/${group}/versions/${epochVerstrId}/readable/${word}`] as const;
    }

    
export const getGetVersionsReadableQueryOptions = <TData = Awaited<ReturnType<typeof getVersionsReadable>>, TError = AxiosError<unknown>>(group: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsReadableQueryKey(group,epochVerstrId,word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsReadable>>> = ({ signal }) => getVersionsReadable(group,epochVerstrId,word, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && epochVerstrId && word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionsReadable>>, TError, TData> & { queryKey: QueryKey }
}

export type GetVersionsReadableQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionsReadable>>>
export type GetVersionsReadableQueryError = AxiosError<unknown>

export const useGetVersionsReadable = <TData = Awaited<ReturnType<typeof getVersionsReadable>>, TError = AxiosError<unknown>>(
 group: string,
    epochVerstrId: string,
    word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsReadable>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetVersionsReadableQueryOptions(group,epochVerstrId,word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionsUris = (
    group: string,
    epochVerstrId: string,
    uriPath: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/versions/${epochVerstrId}/uris/${uriPath}`,options
    );
  }


export const getGetVersionsUrisQueryKey = (group: string,
    epochVerstrId: string,
    uriPath: string,) => {
    return [`/api/v1/${group}/versions/${epochVerstrId}/uris/${uriPath}`] as const;
    }

    
export const getGetVersionsUrisQueryOptions = <TData = Awaited<ReturnType<typeof getVersionsUris>>, TError = AxiosError<unknown>>(group: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsUrisQueryKey(group,epochVerstrId,uriPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsUris>>> = ({ signal }) => getVersionsUris(group,epochVerstrId,uriPath, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && epochVerstrId && uriPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionsUris>>, TError, TData> & { queryKey: QueryKey }
}

export type GetVersionsUrisQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionsUris>>>
export type GetVersionsUrisQueryError = AxiosError<unknown>

export const useGetVersionsUris = <TData = Awaited<ReturnType<typeof getVersionsUris>>, TError = AxiosError<unknown>>(
 group: string,
    epochVerstrId: string,
    uriPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsUris>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetVersionsUrisQueryOptions(group,epochVerstrId,uriPath,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionsIlx = (
    group: string,
    epochVerstrId: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/versions/${epochVerstrId}/${fragPrefId}`,options
    );
  }


export const getGetVersionsIlxQueryKey = (group: string,
    epochVerstrId: string,
    fragPrefId: string,) => {
    return [`/api/v1/${group}/versions/${epochVerstrId}/${fragPrefId}`] as const;
    }

    
export const getGetVersionsIlxQueryOptions = <TData = Awaited<ReturnType<typeof getVersionsIlx>>, TError = AxiosError<unknown>>(group: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionsIlxQueryKey(group,epochVerstrId,fragPrefId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsIlx>>> = ({ signal }) => getVersionsIlx(group,epochVerstrId,fragPrefId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && epochVerstrId && fragPrefId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionsIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetVersionsIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionsIlx>>>
export type GetVersionsIlxQueryError = AxiosError<unknown>

export const useGetVersionsIlx = <TData = Awaited<ReturnType<typeof getVersionsIlx>>, TError = AxiosError<unknown>>(
 group: string,
    epochVerstrId: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetVersionsIlxQueryOptions(group,epochVerstrId,fragPrefId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getEndpointsIlx = (
    group: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/${fragPrefId}`,options
    );
  }


export const getGetEndpointsIlxQueryKey = (group: string,
    fragPrefId: string,) => {
    return [`/api/v1/${group}/${fragPrefId}`] as const;
    }

    
export const getGetEndpointsIlxQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsIlx>>, TError = AxiosError<unknown>>(group: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsIlxQueryKey(group,fragPrefId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsIlx>>> = ({ signal }) => getEndpointsIlx(group,fragPrefId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && fragPrefId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlx>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsIlxQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsIlx>>>
export type GetEndpointsIlxQueryError = AxiosError<unknown>

export const useGetEndpointsIlx = <TData = Awaited<ReturnType<typeof getEndpointsIlx>>, TError = AxiosError<unknown>>(
 group: string,
    fragPrefId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlx>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsIlxQueryOptions(group,fragPrefId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const patchEndpointsIlx = (
    group: string,
    fragPrefId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.patch(
      `/api/v1/${group}/${fragPrefId}`,undefined,options
    );
  }



export const getPatchEndpointsIlxMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsIlx>>, TError,{group: string;fragPrefId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsIlx>>, TError,{group: string;fragPrefId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchEndpointsIlx>>, {group: string;fragPrefId: string}> = (props) => {
          const {group,fragPrefId} = props ?? {};

          return  patchEndpointsIlx(group,fragPrefId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchEndpointsIlxMutationResult = NonNullable<Awaited<ReturnType<typeof patchEndpointsIlx>>>
    
    export type PatchEndpointsIlxMutationError = AxiosError<unknown>

    export const usePatchEndpointsIlx = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchEndpointsIlx>>, TError,{group: string;fragPrefId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchEndpointsIlx>>,
        TError,
        {group: string;fragPrefId: string},
        TContext
      > => {

      const mutationOptions = getPatchEndpointsIlxMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getEndpointsIlxGet = (
    group: string,
    fragPrefId: string,
    extension: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `/api/v1/${group}/${fragPrefId}.${extension}`,options
    );
  }


export const getGetEndpointsIlxGetQueryKey = (group: string,
    fragPrefId: string,
    extension: string,) => {
    return [`/api/v1/${group}/${fragPrefId}.${extension}`] as const;
    }

    
export const getGetEndpointsIlxGetQueryOptions = <TData = Awaited<ReturnType<typeof getEndpointsIlxGet>>, TError = AxiosError<unknown>>(group: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlxGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEndpointsIlxGetQueryKey(group,fragPrefId,extension);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEndpointsIlxGet>>> = ({ signal }) => getEndpointsIlxGet(group,fragPrefId,extension, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(group && fragPrefId && extension), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlxGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEndpointsIlxGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEndpointsIlxGet>>>
export type GetEndpointsIlxGetQueryError = AxiosError<unknown>

export const useGetEndpointsIlxGet = <TData = Awaited<ReturnType<typeof getEndpointsIlxGet>>, TError = AxiosError<unknown>>(
 group: string,
    fragPrefId: string,
    extension: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEndpointsIlxGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEndpointsIlxGetQueryOptions(group,fragPrefId,extension,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




